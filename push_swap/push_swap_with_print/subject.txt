							ВВЕДЕНИЕ.
Этот проект заставит вас сортировать данные в стеке с ограниченным набором
инструкций, используя наименьшее возможное количество действий. Чтобы добиться
успеха, вам придется манипулировать различными типами алгоритмов и выбирать одно
 (из многих) наиболее подходящее решение для оптимизированной сортировки данных.

							ВВЕДЕНИЕ.
Проект Push_swap — это очень простой и высокоэффективный проект алгоритма: данные
нужно будет отсортировать. В вашем распоряжении набор значений int, 2 стека и
набор инструкций для управления обоими стеками.
Ваша цель? Напишите программу на C с именем push_swap, которая вычисляет и
отображает на стандартном выходе наименьшую программу, используя язык инструкций
Push_swap, который сортирует полученные целочисленные аргументы.
Легкий?
Мы увидим об этом ...

							ЦЕЛИ.
Написание алгоритма сортировки всегда является очень важным шагом в жизни
программиста, потому что зачастую это первое знакомство с понятием сложности.
Алгоритмы сортировки и их сложности являются частью классических вопросов,
обсуждаемых на собеседованиях. Вероятно, самое время взглянуть на эти концепции,
потому что вам придется столкнуться с ними в какой-то момент.
Учебными целями этого проекта являются строгость, использование C и использование
основных алгоритмов.
Особенно глядя на сложность этих основных алгоритмов.
Сортировка значений проста. Отсортировать их самым быстрым способом не так просто,
особенно потому, что от одной целочисленной конфигурации к другой наиболее
эффективный алгоритм сортировки может различаться.

							ОСНОВНЫЕ ИНСТРУКЦИИ.
Этот проект будет исправляться только настоящими людьми. Таким образом, вы можете
организовать и назвать свои файлы по своему усмотрению, хотя вам необходимо
соблюдать некоторые требования, перечисленные ниже.
• Исполняемый файл должен называться push_swap.
• Вы должны отправить Makefile. Этот Makefile необходим для компиляции проекта и
должен содержать обычные правила. Он может перекомпилировать программу только в
случае необходимости.
• Если вы сообразительны, вы будете использовать свою библиотеку для этого проекта,
отправьте также свою папку libft, включая собственный Makefile, в корневом каталоге
вашего репозитория. Ваш Makefile должен будет скомпилировать библиотеку, а затем
скомпилировать ваш проект.
• Глобальные переменные запрещены.
• Ваш проект должен быть написан на C в соответствии с Нормой.
• Вы должны реагировать на ошибки деликатно. Ни в коем случае ваша программа не
может завершиться неожиданным образом (ошибка сегментации, ошибка шины, двойное
освобождение и т. д.).
• Ни одна из программ не может иметь утечек памяти.
• В обязательной части вам разрешено использовать следующие функции:
◦ write
◦ read
◦ malloc
◦ free
◦ exit

• Вы можете задавать вопросы на форуме и в Slack...

							ОБЯЗАТЕЛЬНАЯ ЧАСТЬ.
V.1 Правила игры
• Игра состоит из 2 стопок с именами a и b.
• Начать с:
◦ стек a содержит случайное количество отрицательных и/или положительных чисел,
которые не могут быть продублированы.
◦ b пусто
• Цель состоит в том, чтобы отсортировать числа в порядке возрастания в стеке a.
• Для этого в вашем распоряжении следующие операции:
sa : swap a — поменять местами первые 2 элемента в верхней части стека a. Ничего
не делать, если есть только один элемент или его нет).
sb : swap b — поменять местами первые 2 элемента в верхней части стека b. Ничего
не делать, если есть только один элемент или его нет).
ss : sa и sb одновременно.
pa : push a — взять первый элемент в верхней части b и поместить его в верхнюю
часть a. Ничего не делать, если b пусто.
pb : push b — взять первый элемент в верхней части a и поместить его в верхнюю
часть b. Ничего не делать, если a пусто.
ra : rotate a - сдвигает вверх все элементы стека a на 1. Первый элемент
становится последним.
rb : rotate b - сдвинуть вверх все элементы стека b на 1. Первый элемент
становится последним.
rr : ra и rb одновременно.
rra : reverse rotate a - сдвигает вниз все элементы стека a на 1. Последний
элемент становится первым.
rrb : reverse rotate b - сдвинуть вниз все элементы стека b на 1. Последний
элемент становится первым.
rrr : rra  и rrb одновременно.

							ПРИМЕР.
Чтобы проиллюстрировать действие некоторых из этих инструкций, давайте отсортируем
случайный список целых чисел. В этом примере мы будем считать, что оба стека
растут справа.

--------------------------------------------------------------------------------
Init a and b:
2
1
3
6
5
8
_ _
a b
--------------------------------------------------------------------------------
Exec sa:
1
2
3
6
5
8
_ _
a b
--------------------------------------------------------------------------------
Exec pb pb pb:
6 3
5 2
8 1
_ _
a b
--------------------------------------------------------------------------------
Exec ra rb (equiv. to rr):
5 2
8 1
6 3
_ _
a b
--------------------------------------------------------------------------------
Exec rra rrb (equiv. to rrr):
6 3
5 2
8 1
_ _
a b
--------------------------------------------------------------------------------
Exec sa:
5 3
6 2
8 1
_ _
a b
--------------------------------------------------------------------------------
Exec pa pa pa:
1
2
3
5
6
8
_ _
a b
--------------------------------------------------------------------------------
В этом примере сортируются целые числа из a за 12 инструкций. Можете ли вы
сделать лучше?

							V.3 ПРОГРАММА «PUSH_SWAP».
• Вы должны написать программу с именем push_swap, которая будет получать в
качестве аргумента стек, отформатированный как список целых чисел. Первый аргумент
должен быть на вершине стека (будьте осторожны с порядком).
• Программа должна отображать наименьший список инструкций, возможный для
сортировки стека a, при этом наименьшее число должно находиться вверху.
• Инструкции должны быть разделены символом '\n' и ничем другим.
• Цель состоит в том, чтобы отсортировать стек с минимально возможным количеством
операций. Во время защиты мы сравним количество инструкций, найденных вашей
программой, с максимально допустимым количеством операций. Если ваша программа
отображает слишком большой список или если список не отсортирован должным образом,
вы не получите баллов.
• Если параметры не указаны, программа не должна ничего отображать и возвращать
подсказку.
• В случае ошибки вы должны отобразить Error, а затем '\n' на стандартной ошибке.
Ошибки включают, например: некоторые аргументы не являются целыми числами,
некоторые аргументы больше целого числа и/или есть дубликаты.

$>./push_swap 2 1 3 6 5 8
sa
pb
pb
pb
sa
pa
pa
pa
$>./push_swap 0 one 2 3
Error
$>

Во время защиты предоставим бинарник для правильной проверки вашей программы. Это
будет работать следующим образом:

$>ARG="4 67 3 87 23"; ./push_swap $ARG | wc -l
6
$>ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG
OK
$>

Если программа checker_OS выводит KO, значит, ваш push_swap выдал список инструкций,
который не сортирует список. Программа checker_OS доступна в ресурсах проекта в
интранете. Вы можете найти в бонусной части этого документа описание того, как
это работает.

							БОНУСНАЯ ЧАСТЬ.
Мы рассмотрим вашу бонусную часть тогда и только тогда, когда ваша обязательная
часть будет ОТЛИЧНОЙ. Это означает, что вы должны выполнить обязательную часть,
от начала до конца, и ваше управление ошибками должно быть безупречным, даже в
случаях искаженного или неправильного использования. Если это не так, ваши бонусы
будут полностью ИГНОРИРОВАНЫ. Проект Push_swap мало подходит для создания бонусов
из-за своей простоты. Однако как насчет создания собственного чекера?

							VI.1 ПРОГРАММА "ПРОВЕРКА"
• Напишите программу checker, которая будет получать в качестве аргумента стек,
отформатированный как список целых чисел. Первый аргумент должен быть на вершине
стека (будьте осторожны с порядком). Если аргумент не задан, проверка
останавливается и ничего не отображает.
• Затем программа проверки будет ждать и читать инструкции на стандартном вводе,
за каждой инструкцией будет следовать '\n'. Как только все инструкции будут
прочитаны, чекер выполнит их в стеке, полученном в качестве аргумента.
• Если после выполнения этих инструкций стек a действительно отсортирован, а b
пуст, то программа проверки должна отобразить «ОК», а затем «\n» в стандартном
выводе. Во всех остальных случаях программа проверки должна отображать «KO», за
которой следует «\n» на стандартном выходе.
• В случае ошибки вы должны отобразить Error, а затем '\n' на стандартной ошибке.
Ошибки включают, например: некоторые аргументы не являются целыми числами,
некоторые аргументы больше целого числа, есть дубликаты, инструкция не существует
и/или имеет неправильный формат.

	Благодаря программе проверки вы сможете проверить, действительно ли список
	инструкций, который вы сгенерируете с помощью программы push_swap, правильно
	сортирует стек.

$>./checker 3 2 1 0
rra
pb
sa
rra
pa
OK
$>./checker 3 2 1 0
sa
rra
pb
KO
$>./checker 3 2 one 0
Error
$>./checker "" 1
Error
$>

	Вам НЕ ОБЯЗАТЕЛЬНО воспроизводить точно такое же поведение, как в бинарном
	файле, который мы вам даем. Обработка ошибок обязательна, но вам решать, как
	вы решите анализировать аргументы
